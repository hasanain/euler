import java.util.Date;

/*
 Project Euler Problem 61
 ========================

 Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 are all figurate (polygonal) numbers and are generated by the following
 formulae:

 Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
 Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
 Pentagonal   P[5,n]=n(3n-1)/2   1, 5, 12, 22, 35, ...
 Hexagonal    P[6,n]=n(2n-1)     1, 6, 15, 28, 45, ...
 Heptagonal   P[7,n]=n(5n-3)/2   1, 7, 18, 34, 55, ...
 Octagonal    P[8,n]=n(3n-2)     1, 8, 21, 40, 65, ...

 The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 interesting properties.

 1. The set is cyclic, in that the last two digits of each number is the
 first two digits of the next number (including the last number with
 the first).
 2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281),
 and pentagonal (P[5,44]=2882), is represented by a different number in
 the set.
 3. This is the only set of 4-digit numbers with this property.

 Find the sum of the only ordered set of six cyclic 4-digit numbers for
 which each polygonal type: triangle, square, pentagonal, hexagonal,
 heptagonal, and octagonal, is represented by a different number in the
 set.
 */

public class Euler061 {
	public static void main(String[] args) {
		Date start, end;
		start = new Date();
		System.out.println(isCyclic(8128, 2882, 8281));
		int m = triangle(1/* 45 */), n = square(1/* 32 */), o = pentagonal(1), p = hexagonal(1), q = heptagonal(1), r = octagonal(1);
		int counterM = 1;
		while (m < 1000) {
			m = triangle(++counterM);
		}
		int counterN = 1;
		while (n < 1000) {
			n = square(++counterN);
		}
		int counterO = 1;
		while (o < 1000) {
			o = pentagonal(++counterO);
		}
		int counterP = 1;
		while (p < 1000) {
			p = hexagonal(++counterP);
		}
		int counterQ = 1;
		while (q < 1000) {
			q = heptagonal(++counterQ);
		}
		int counterR = 1;
		while (r < 1000) {
			r = octagonal(++counterR);
		}

		int origM = counterM, origN = counterN, origO = counterO, origP = counterP, origQ = counterQ, origR = counterR;
		while ((m = triangle(counterM++)) < 10000) {
			counterN = origN;
			while ((n = square(counterN++)) < 10000) {
				counterO = origO;
				while ((o = pentagonal(counterO++)) < 10000) {
					counterP = origP;
					while ((p = hexagonal(counterP++)) < 10000) {
						counterQ = origQ;
						while((q = heptagonal(counterQ++)) < 10000){
							counterR = origR;
							while((r = pentagonal(counterR++)) < 10000){
								if (isCyclic(m, n, o, p,q,r) || isCyclic(m, o, n, q, p ,r)
										|| isCyclic(n, m, o) || isCyclic(n, o, m)
										|| isCyclic(o, m, n) || isCyclic(o, n, m)) {
									System.out
											.printf("triangle = %d, square = %d, pentagon = %d, hexagon = %d\n",
													m, n, o, p);
									System.out.println((m + n + o + p));
								}
							}
						}
						
					}
				}

			}
			// System.out.printf("triangle = %d, square = %d\n", m, n);

		}

		// while (m < 10000) {
		// m = triangle(++counterM);
		// while (n < 10000) {
		// n = square(++counterN);
		// while (o < 10000) {
		// o = pentagonal(++counterO);
		// while (p < 10000) {
		// p = hexagonal(++counterP);
		// while (q < 10000) {
		// q = heptagonal(++counterQ);
		// while (r < 10000) {
		// r = octagonal(++counterR);
		// if (isCyclic(m, n, o, p, q, r)) {
		// System.out
		// .printf("traingle = %d, square = %d, pentagon = %d, hexagon = %d, heptagon = %d, octagon = %d\n",
		// m, n, o, p, q, r);
		// }
		//
		// }
		//
		// r = origR;
		// }
		//
		// q = origQ;
		//
		// }
		//
		// p = origP;
		//
		// }
		//
		// o = origO;
		//
		// }
		//
		// n = origN;
		//
		// }

		end = new Date();
		System.out.println("Execution Time: "
				+ (end.getTime() - start.getTime()));
	}

	public static int triangle(int n) {
		return n * (n - 1) / 2;
	}

	public static int square(int n) {
		return (int) Math.pow(n, 2);
	}

	public static int pentagonal(int n) {
		return n * (3 * n - 1) / 2;
	}

	public static int hexagonal(int n) {
		return n * (2 * n - 1);
	}

	public static int heptagonal(int n) {
		return n * (5 * n - 3) / 2;
	}

	public static int octagonal(int n) {
		return n * (3 * n - 2);
	}

	public static boolean isCyclic(int... numbers) {
		
		for (int i = 0; i < numbers.length - 1; i++) {
			if (numbers[i] % 100 != (numbers[i + 1] / 100) % 100) {
				return false;
			}
		}
		int first = (numbers[0] / 100) % 100;
		int last = (numbers[numbers.length - 1]) % 100;
		if (first != last) {
			return false;
		}
		return true;
	}
}
